/*! For license information please see 43cb9881.2fbfe46b.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[671601],{398352:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>l,frontMatter:()=>i,metadata:()=>c,toc:()=>h});var s=n(474848),r=n(28453);const i={id:"http-auth",title:"Http Auth Service",sidebar_label:"Http Auth",description:"Documentation for the Http Auth service"},o=void 0,c={id:"backend-system/core-services/http-auth",title:"Http Auth Service",description:"Documentation for the Http Auth service",source:"@site/../docs/backend-system/core-services/http-auth.md",sourceDirName:"backend-system/core-services",slug:"/backend-system/core-services/http-auth",permalink:"/docs/next/backend-system/core-services/http-auth",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/backend-system/core-services/http-auth.md",tags:[],version:"current",frontMatter:{id:"http-auth",title:"Http Auth Service",sidebar_label:"Http Auth",description:"Documentation for the Http Auth service"},sidebar:"docs",previous:{title:"Discovery",permalink:"/docs/next/backend-system/core-services/discovery"},next:{title:"Http Router",permalink:"/docs/next/backend-system/core-services/http-router"}},a={},h=[{value:"Using the Service",id:"using-the-service",level:2},{value:"Getting Request Credentials",id:"getting-request-credentials",level:3},{value:"Issuing Cookies",id:"issuing-cookies",level:3},{value:"Configuring the service",id:"configuring-the-service",level:2},{value:"Custom token extraction logic",id:"custom-token-extraction-logic",level:3}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"httpAuth"})," service deals with submitting and receiving credentials on Express\nHTTP request/response objects. This service is frequently used in plugins that\nhave REST interfaces."]}),"\n",(0,s.jsxs)(t.p,{children:["If you want to deal with raw tokens and do low level credentials handling, see\nalso ",(0,s.jsxs)(t.a,{href:"/docs/next/backend-system/core-services/auth",children:["the ",(0,s.jsx)(t.code,{children:"auth"})," service"]}),". If you want to extract more details about\nauthenticated users such as their ownership entity refs, use ",(0,s.jsxs)(t.a,{href:"/docs/next/backend-system/core-services/user-info",children:["the ",(0,s.jsx)(t.code,{children:"userInfo"})," service"]}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"using-the-service",children:"Using the Service"}),"\n",(0,s.jsxs)(t.p,{children:["In the following code examples, the ",(0,s.jsx)(t.code,{children:"auth"})," and ",(0,s.jsx)(t.code,{children:"httpAuth"})," variables are assumed\nto be dependency-injected instances of the ",(0,s.jsx)(t.code,{children:"coreServices.auth"})," and\n",(0,s.jsx)(t.code,{children:"coreServices.httpAuth"})," service, respectively. For a backend plugin, it might\nlook like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"export default createBackendPlugin({\n  pluginId: 'my-plugin',\n  register(env) {\n    env.registerInit({\n      deps: {\n        auth: coreServices.auth,\n        httpAuth: coreServices.httpAuth,\n        httpRouter: coreServices.httpRouter,\n      },\n      async init({ auth, httpAuth, httpRouter }) {\n        // Your code goes here\n      },\n    });\n  },\n});\n"})}),"\n",(0,s.jsx)(t.h3,{id:"getting-request-credentials",children:"Getting Request Credentials"}),"\n",(0,s.jsx)(t.p,{children:"If you need to extract the validated credentials out of an incoming request, you\ncan do so like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"router.get('/some-request', async (req, res) => {\n  const credentials = await httpAuth.credentials(req, { allow: ['user'] });\n  // Do something with the credentials here\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The second argument is optional, but in this example we specified that we only\nwant to allow user based requests. The credentials returned will then have a\nnarrowed TypeScript type that reflects that the principal is known to be of the\nuser type. This second argument can also specify ",(0,s.jsx)(t.code,{children:"allowLimitedAccess: true"})," if\nyou specifically built a plugin that deals with cookie based access, which is\nrare."]}),"\n",(0,s.jsx)(t.p,{children:"The default is to accept both service and user credentials (excluding limited\naccess), but in the example above, any attempt to call this endpoint with\nservice credentials will result in an Unauthorized error being thrown."}),"\n",(0,s.jsx)(t.admonition,{title:"Note",type:"note",children:(0,s.jsxs)(t.p,{children:["You don't need to call ",(0,s.jsx)(t.code,{children:"httpAuth.credentials"})," ",(0,s.jsx)(t.em,{children:"just"})," to ensure that incoming\ncredentials are valid in the first place; only use this method if you actually\nneed to act upon the credentials somehow. The Backstage backend framework will have\nensured the actual validity of any incoming token before your backend code is\nreached. The policy for these upfront framework level rules is controlled using\n",(0,s.jsxs)(t.a,{href:"/docs/next/backend-system/core-services/http-router",children:["the ",(0,s.jsx)(t.code,{children:"httpRouter"})," service"]})," when you register your routes."]})}),"\n",(0,s.jsxs)(t.p,{children:["If you want to further work with the credentials object, ",(0,s.jsxs)(t.a,{href:"/docs/next/backend-system/core-services/auth",children:["the ",(0,s.jsx)(t.code,{children:"auth"})," service"]}),"\nhas helper methods for that."]}),"\n",(0,s.jsx)(t.h3,{id:"issuing-cookies",children:"Issuing Cookies"}),"\n",(0,s.jsxs)(t.p,{children:["For some rare use cases, plugins may want to issue cookies with ",(0,s.jsx)(t.em,{children:"limited access"}),"\nuser credentials. This is mostly relevant when browsers need to be able to\nrequest static resources, such as in the TechDocs plugin."]}),"\n",(0,s.jsxs)(t.p,{children:["Plugins should almost never interact with the cookie functionality of the\n",(0,s.jsx)(t.code,{children:"httpAuth"})," service directly. The framework has builtin handling of cookie\ncreation/deletion requests on a dedicated well-known endpoint. All you normally\nhave to do to accept limited user access is to inform ",(0,s.jsxs)(t.a,{href:"/docs/next/backend-system/core-services/http-router",children:["the ",(0,s.jsx)(t.code,{children:"httpRouter"})," service"]}),"\nwhen creating your route that you want to permit\ncookie based access for a specific route, and then setting ",(0,s.jsx)(t.code,{children:"allowLimitedAccess"}),"\nto ",(0,s.jsx)(t.code,{children:"true"})," when extracting credentials."]}),"\n",(0,s.jsxs)(t.p,{children:["Due to the above, we do not document the ",(0,s.jsx)(t.code,{children:"httpAuth.issueUserCookie"})," method here."]}),"\n",(0,s.jsx)(t.h2,{id:"configuring-the-service",children:"Configuring the service"}),"\n",(0,s.jsx)(t.admonition,{title:"Note",type:"note",children:(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"httpAuth"})," service is not suitable for having its implementation replaced\nentirely in your private repo. If you desire additional service auth related\nfeatures, don't hesitate to ",(0,s.jsx)(t.a,{href:"https://github.com/backstage/backstage/issues/new/choose",children:"file an issue"}),"\nor ",(0,s.jsx)(t.a,{href:"https://github.com/backstage/backstage/blob/master/CONTRIBUTING.md",children:"contribute"})," to the open source features."]})}),"\n",(0,s.jsx)(t.h3,{id:"custom-token-extraction-logic",children:"Custom token extraction logic"}),"\n",(0,s.jsxs)(t.p,{children:["In some cases, you might want to customize how tokens are extracted from incoming requests. It might be that you want to extract tokens from a different location in the request. To support this you can supply your own slightly modified httpAuth service. The ",(0,s.jsx)(t.code,{children:"DefaultHttpAuthService"})," class is exported from ",(0,s.jsx)(t.code,{children:"@backstage/backend-defaults/httpAuth"})," and it's static ",(0,s.jsx)(t.code,{children:"create"})," method can be used to pass in a custom ",(0,s.jsx)(t.code,{children:"getTokenFromRequest"})," extraction function."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"import { DefaultHttpAuthService } from '@backstage/backend-defaults/httpAuth';\nimport {\n  coreServices,\n  createServiceFactory,\n} from '@backstage/backend-plugin-api';\n\nexport const customizedAuthServiceFactory = createServiceFactory({\n  service: coreServices.httpAuth,\n  deps: {\n    auth: coreServices.auth,\n    discovery: coreServices.discovery,\n    plugin: coreServices.pluginMetadata,\n  },\n  async factory({ auth, discovery, plugin }) {\n    return DefaultHttpAuthService.create({\n      auth,\n      discovery,\n      pluginId: plugin.getId(),\n      getTokenFromRequest: req => {\n        let token: string | undefined;\n        const header = req.headers.some_random_header;\n        if (typeof header === 'string') {\n          const parts = header.split(' ');\n          if (parts.length === 2 && parts[0] === 'Bearer') {\n            token = parts[1];\n          }\n        }\n        return { token };\n      },\n    });\n  },\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This service has no configuration options, but it abides by the policies you\nhave set up using ",(0,s.jsxs)(t.a,{href:"/docs/next/backend-system/core-services/http-router",children:["the ",(0,s.jsx)(t.code,{children:"httpRouter"})," service"]})," for your routes,\nif any."]})]})}function l(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},221020:(e,t,n)=>{var s=n(296540),r=Symbol.for("react.element"),i=Symbol.for("react.fragment"),o=Object.prototype.hasOwnProperty,c=s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,a={key:!0,ref:!0,__self:!0,__source:!0};function h(e,t,n){var s,i={},h=null,d=null;for(s in void 0!==n&&(h=""+n),void 0!==t.key&&(h=""+t.key),void 0!==t.ref&&(d=t.ref),t)o.call(t,s)&&!a.hasOwnProperty(s)&&(i[s]=t[s]);if(e&&e.defaultProps)for(s in t=e.defaultProps)void 0===i[s]&&(i[s]=t[s]);return{$$typeof:r,type:e,key:h,ref:d,props:i,_owner:c.current}}t.Fragment=i,t.jsx=h,t.jsxs=h},474848:(e,t,n)=>{e.exports=n(221020)},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>c});var s=n(296540);const r={},i=s.createContext(r);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);